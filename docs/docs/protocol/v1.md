---
description: (WIP) Spec document for version 1 of the v5dbg debug server protocol
---

# V5 Debugger Server Protocol v1

## Constants

The following constants will be used throughout the protocol documentation.

| Constant      | Value         |
| ------------- | ------------- |
| Newline      | `\n` |
| Message       | A string of characters with a newline at the end |
| Message separator | `:` |
| Debugger | The program that connects to the debug server over serial |
| Debug server | Program that runs on the brain and provides debugging functions over serial |
| Remote | Device running the debug server |
| Local | Device running the debugger | 
| Protocol version | The number used to determine the version of the protocol |

## Communication

v5dbg communicates over USB serial using the standard `printf` function. Incoming commands are read from `std::cin` on the debug server's IO thread and are pushed into a message queue which is read by the main thread. Data is automatically sent to the computer using the V5 serial protocol which will not be discussed in this document.

## Messages

Messages are payloads of data sent from either the debugger, or debug server. All messages are formatted as follows, left to right.

* Message begin `%`
* Protocol version: Constant `1`
* Message type
* Message payload
* Newline

An example message can be seen as `%1:1:0`, message type one is program suspend. It should be noted that if more than three [message seperator](#constants) characters are used then any located after the third are ignored and are merged into the message payload.

If we have the message `%1:2:0:1:2:3` then the message payload should be `0:1:2:3`, the extra message separator characters do not mess up the parser state and does not throw a warning or error of any kind

## Message Types

Message types are defined as enums within `v5dbg/protocol.h` (include directory), the `DEBUGGER_MESSAGE_MAX` is used as a basic check to determine if a message type is invalid. 

Message IDs can be considered `unsigned int`s since they never can be negative, and a message should be assumed invalid or corrupted if so.

```c++
enum v5dbg_message_type_e
{
  /// @brief  Connection opened
  DEBUGGER_MESSAGE_OPEN = 0,

  /// @brief  Request program suspension, assume it has occurred when a DEBUG_MESSAGE_RSUSPEND is parsed
  DEBUGGER_MESSAGE_SUSPEND = 1,

  /// @brief  Connection closed
  DEBUGGER_MESSAGE_CLOSE = 2,

  /// @brief  Allocate a string, can be processed by the debugger however it likes
  DEBUGGER_MESSAGE_ALLOCATE_STRING = 3,

  /// @brief  Resume the program from a suspended state
  DEBUGGER_MESSAGE_RESUME = 4,

  /// @brief  Respond with DEBUGGER_MESSAGE_RTHREADS containing a comma separated list of every thread being managed by
  /// v5dbg
  DEBUGGER_MESSAGE_THREADS = 5,

  /// @brief  Return message for DEBUGGER_MESSAGE_THREADS
  DEBUGGER_MESSAGE_RTHREADS = 6,

  /// @brief  Get the vstack for the given thread index
  DEBUGGER_MESSAGE_VSTACK_FOR = 7,

  /// @brief  Return message for DEBUGGER_MESSAGE_VSTACK_FOR, keep accepting messages until DEBUGGER_MESSAGE_VSTACK_END
  DEBUGGER_MESSAGE_RVSTACK = 8,

  /// @brief  Stop accepting DEBUGGER_MESSAGE_RVSTACK messages
  DEBUGGER_MESSAGE_VSTACK_END = 9,

  /// @brief  List memory for the given stack frame with thread ID
  DEBUGGER_MESSAGE_LMEM_FOR = 10,

  /// @brief  Returned message for DEBUGGER_MESSAGE_LMEM_FOR, keep accepting messages until DEBUGGER_MESSAGE_LMEM_END
  DEBUGGER_MESSAGE_RLMEM = 11,

  /// @brief  Stop accepting DEBUGGER_MESSAGE_RLMEM messages
  DEBUGGER_MESSAGE_LMEM_END = 12,

  /// @brief  Max debugger message ID
  DEBUGGER_MESSAGE_MAX = 13
};
```

## Behaviors

### `DEBUGGER_MESSAGE_SUSPEND`

Requests the debug server to suspend all of its managed threads, no response is sent to the client.

### `DEBUGGER_MESSAGE_VSTACK_FOR`

Returns a series of `DEBUGGER_MESSAGE_RVSTACK` for each frame of the stack before ending with a `DEBUGGER_MESSAGE_VSTACK_END`

| Parameter      | Docs         |
| ------------- | ------------- |
| Index 0 | `unsigned int` of the thread ID to grab the callstack for |