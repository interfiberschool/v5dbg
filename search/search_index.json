{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"V5 Debugger","text":"<p>The only true VEX debugger\u2122</p> <p>V5dbg is still experimental</p> <p>v5dbg is still under HEAVY development and the documentation may not reflect the current state of the library and program.</p> <p> Bug Tracker</p> <p> Releases Page</p>"},{"location":"#what-can-v5dbg-do","title":"What can v5dbg do?","text":"<ul> <li> <p> Set software breakpoints</p> <ul> <li>Set breakpoints on function entrance/exit, memory allocations, and in manual locations.</li> <li>Conditional breakpoints <code>$cbreak</code></li> </ul> <p> C++ Documentation</p> <p> Debugger Documentation</p> </li> <li> <p> Inspect active threads</p> <ul> <li>View active locks and which threads hold them</li> <li>View the current callstack for a thread at any time</li> <li>Easily switch the debuggers active context to another thread</li> </ul> <p> C++ Documentation</p> <p> Debugger Documentation</p> </li> <li> <p> Inspect, set, and manage memory</p> <ul> <li>Automatically pretty print variables based on compile-time type information</li> <li>Set memory value to a constant, variable constant, or temporary value</li> </ul> <p> C++ Documentation</p> <p> Debugger Documentation</p> </li> <li> <p> Inspect device states</p> <ul> <li>Motor information</li> <li>Battery power</li> <li>Connected remote information</li> <li>Radio I/O</li> </ul> <p> C++ Documentation</p> <p> Debugger Documentation</p> </li> </ul> <p>Ready to get started?</p>"},{"location":"cpp/header_files/","title":"Header files","text":"File Description <code>v5dbg/debug.h</code> All debug macros for user programs <code>v5dbg/memory.h</code> Memory object handling <code>v5dbg/protocol.h</code> Debug protocol spec <code>v5dbg/debinfo.h</code> Runtime debug info <code>v5dbg/pretty.h</code> Pretty printer functions <code>v5dbg/debugger.h</code> Debugger functions (suspend, resume) <code>v5dbg/msg.h</code> Message handling definitions <code>v5dbg/stack.h</code> Stack reconstruction <code>v5dbg/server.h</code> Debug server implementation <code>v5dbg/util.h</code> Utility functions"},{"location":"cpp/macros/debug/function/","title":"<code>$function</code>","text":"<p>Version information</p> <p>Introduced in version v0.1 </p> <p>This macro is considered stable </p>"},{"location":"cpp/macros/debug/function/#about","title":"About","text":"<p>The <code>$function</code> macro allows v5dbg to generate a backtrace to determine the current point of execution. When placed at the top of a function it adds debug information to the current backtrace, when the function exits its then removed.</p> Why do I need to use this macro? <p>Unlike traditional debuggers which can ask the operating system for a backtrace and can then convert the returned addresses into symbol names, v5dbg runs on an environment where this is not possible (yet).</p> <p>As a workaround <code>$function</code> traces where it was called from to determine the proper line of execution.</p>"},{"location":"cpp/macros/debug/function/#notes","title":"Notes","text":"<p>Required environment</p> <ul> <li>This macro requires the debug server to have been initialized before being called.</li> <li>This macro requires the current thread to be supervised with $ntask or <code>V5Dbg_Init</code></li> </ul>"},{"location":"cpp/macros/debug/function/#examples","title":"Examples","text":"Example 1 (Single function)Example 2 <pre><code>#include \"v5dbg/debug.h\"\n\nvoid\nopcontrol()\n{\n    $ntask // (1)!\n    $function // (2)!\n\n    while (true)\n    {\n        // Print \"Hello World\" to the screen via pros::lcd\n        pros::lcd::print(1, \"Hello World\");\n\n        pros::delay(300);\n    }\n}\n</code></pre> <ol> <li>For more information on <code>$ntask</code> look here</li> <li>Now opcontrol will be the first item in the callstack since it's the first time <code>$function</code> was called on this thread/task.</li> </ol> <pre><code>#include \"v5dbg/debug.h\"\n\nvoid\nprintAndSleep(const std::string &amp;p)\n{\n    $function // (2)!\n    pros::lcd::print(1, \"%s\", p.c_str()); // Print our data to the screen\n\n    pros::delay(300); // Wait 300ms\n}\n\nvoid\nopcontrol()\n{\n    $ntask // (1)!\n    $function\n\n    while (true)\n    {\n        printAndSleep(\"Hello World\");\n    }\n}\n</code></pre> <ol> <li>For more information on <code>$ntask</code> look here</li> <li>Now our <code>printAndSleep</code> function will be the second item in the callstack, it should now look like this:<ul> <li><code>void printAndSleep(const std::string &amp;p)</code></li> <li><code>void opcontrol()</code></li> </ul> </li> </ol>"},{"location":"cpp/macros/debug/ntask/","title":"<code>$ntask</code>","text":"<p>Version information</p> <p>Introduced in version v0.1 </p> <p>This macro is considered stable </p>"},{"location":"cpp/macros/debug/ntask/#about","title":"About","text":"<p>The <code>$ntask</code> macro informs the debug server of a newly spawned thread/task. It should be the first line of code ever executed during a tasks runtime, otherwise other debug macros may not work.</p> <p>Common pitfall</p> <p>When <code>$ntask</code> falls out of scope it will automatically prevent the debugger from supervising the task, make sure that the scope its called in lives until the task is ready to end.</p>"},{"location":"cpp/macros/debug/ntask/#notes","title":"Notes","text":"<p>Required environment</p> <ul> <li>This macro requires the debug server to have been initialized before being called.</li> </ul> <p>Task names</p> <p>Make sure that every task has a unique name otherwise tasks can be confused internally by the debug server.</p>"},{"location":"cpp/macros/debug/ntask/#example","title":"Example","text":"<pre><code>#include \"v5dbg/debug.h\"\n\nvoid\nopcontrol()\n{\n    $ntask // (1)!\n    $function // (2)!\n\n    while (true)\n    {\n        // Print \"Hello World\" to the screen via pros::lcd\n        pros::lcd::print(1, \"Hello World\");\n\n        pros::delay(300);\n    }\n}\n</code></pre> <ol> <li>Our thread is now supervised and we can begin to use other debug macros.</li> <li>For more information on <code>$function</code> look here</li> </ol>"},{"location":"getting_started/integration/","title":"Integration","text":""},{"location":"getting_started/integration/#step-1-allocate-the-server-state-object","title":"Step 1. Allocate the server state object","text":"<p>v5dbg relies on a core server state object to contain the debuggers state. Find a place in your program like <code>main.cpp</code> where you can place the global server state object like below:</p> <pre><code>// .. snip ..\n#include \"v5dbg/server.h\"\n\nv5dbg_server_state_t serverState{};\n</code></pre> <p>Now we can initialize it with <code>V5Dbg_AllocateServerState</code> inside our <code>initialize</code> function like so</p> <pre><code>void\ninitialize()\n{\n    // Allocate server state heap resources\n    serverState = V5Dbg_AllocateServerState();\n}\n</code></pre>"},{"location":"getting_started/integration/#step-2-start-the-debug-server","title":"Step 2. Start the debug server","text":"<p>In order to start integrating v5dbg into our bot code we need to actually start the debug server. Still in our <code>initialize</code> function we can add a call to <code>V5Dbg_StartServer</code> which takes in a pointer to the <code>v5dbg_server_state_t</code> object we allocated in the previous step. Our file should now look similar to whats below</p> <pre><code>#include \"v5dbg/server.h\"\n\nv5dbg_server_state_t serverState{};\n\nvoid\ninitialize()\n{\n    // Allocate server state heap resources\n    serverState = V5Dbg_AllocateServerState();\n\n    // Start the debug server\n    V5Dbg_StartServer(&amp;serverState);\n}\n</code></pre>"},{"location":"getting_started/integration/#step-3-inform-the-debugger-of-new-tasks","title":"Step 3. Inform the debugger of new tasks","text":"<p>Right now the debug server is waiting for messages and API calls. We need to tell the debug server of any new tasks that we create, including ones automatically created by the PROS system daemon, such as <code>opcontrol</code>. Lets just to the first line of code in our <code>opcontrol</code> function.</p> <p>Here lets tell the debugger about the new task using <code>V5Dbg_Init</code></p> <pre><code>void\nopcontrol()\n{\n    // Will automatically tell the debugger to supervise execution of the current task\n    V5Dbg_Init();\n\n    // If we want to be more verbose we can use the following which is what V5Dbg_Init does behind the scenes.\n    V5Dbg_RemoteInit(pros::rtos::Task::current_task());\n\n    while (true)\n    {\n        // ... opcontrol code ...\n    }\n\n    // Our task is about to be deleted so inform the debugger to stop supervising it\n    V5Dbg_Leave();\n}\n</code></pre> <p>V5dbg also offers a macro named <code>$ntask</code> which will automatically supervise and shutdown resources as needed.</p> <pre><code>#include \"v5dbg/debug.h\" // Needed for all debug macros like $ntask\n\nvoid opcontrol()\n{\n    $ntask\n\n    while (true)\n    {\n        // ... opcontrol code ...\n    }\n}\n</code></pre>"},{"location":"getting_started/integration/#step-4-start-tracking-function-calls","title":"Step 4. Start tracking function calls","text":"<p>Now we can use normal debugging macros! At the start of every function we can place a call to <code>$function</code> which will allow the debugger to generate stack traces in realtime when pausing our program. You should also make sure to call <code>$function</code> after informing the debugger of the <code>opcontrol</code> task so it shows up in stack traces!</p> <pre><code>void \nprintData(const std::string &amp;msg)\n{\n    $function\n\n    printf(\"%s\\n\", msg.c_str());\n\n    pros::delay(1000); // So we can see `printData` in the callstack!\n}\n</code></pre> <p>For more information on debugger macros see the Macros section, or view the Debugger Client documentation.</p>"},{"location":"install/server/","title":"Installation","text":"Limitations of v5dbg <p>Please keep the following limitations in mind while using v5dbg.</p> <ul> <li>Every function must begin with <code>$function</code></li> <li>Variables accessible by the debugger must be fed into <code>$expose</code></li> <li>If your program has a fatal crash v5dbg cannot suspend the program.<ul> <li>Try using Symbolizer for VEX V5 in combination with v5dbg.</li> </ul> </li> <li>Line-by-line stepping is not possible</li> </ul>"},{"location":"install/server/#requirements","title":"Requirements","text":"<p>Please read through the requirements carefully</p> <ul> <li>Your user program is developed using PROS</li> <li>PROS toolchain is installed and up-to-date<ul> <li>The easiest way to do this is to use the VSCode extension</li> </ul> </li> </ul>"},{"location":"install/server/#downloading-the-release-archive","title":"Downloading the release archive","text":"<p>Download the latest <code>v5dbg_server.zip</code> from the releases page on GitHub, now extract this archive into your project folder.</p> <p>Pick the correct file!</p> <p>Make sure to download <code>v5dbg_server.zip</code>, and not <code>v5dbg_debugger.zip</code>. </p> Debugger vs Debug Server <p>The debug server is the program that executes on the brain and performs all of the internal debug logic.</p> <p>The debugger is the program that executes on your computer and serves as a frontend to the debug server over USB serial.</p>"},{"location":"install/server/#copy-server-source-code","title":"Copy server source code","text":"<p>Inside the newly created <code>v5dbg</code> folder copy</p> <ul> <li> <code>v5dbg/include/v5dbg</code> into <code>include</code></li> <li> <code>v5dbg/src/v5dbg</code> into <code>src</code></li> </ul>"},{"location":"install/server/#build-your-program","title":"Build your program","text":"<p>Using either the VSCode extension, or by calling <code>pros make</code> from the terminal make sure that your program builds properly, all v5dbg source code files should automatically be detected and compiled in.</p>"},{"location":"protocol/v1/","title":"V5 Debugger Server Protocol v1","text":""},{"location":"protocol/v1/#constants","title":"Constants","text":"<p>The following constants will be used throughout the protocol documentation.</p> Constant Value Newline <code>\\n</code> Message A string of characters with a newline at the end Message separator <code>:</code> Debugger The program that connects to the debug server over serial Debug server Program that runs on the brain and provides debugging functions over serial Remote Device running the debug server Local Device running the debugger Protocol version The number used to determine the version of the protocol"},{"location":"protocol/v1/#communication","title":"Communication","text":"<p>v5dbg communicates over USB serial using the standard <code>printf</code> function. Incoming commands are read from <code>std::cin</code> on the debug server's IO thread and are pushed into a message queue which is read by the main thread. Data is automatically sent to the computer using the V5 serial protocol which will not be discussed in this document.</p>"},{"location":"protocol/v1/#messages","title":"Messages","text":"<p>Messages are payloads of data sent from either the debugger, or debug server. All messages are formatted as follows, left to right.</p> <ul> <li>Message begin <code>%</code></li> <li>Protocol version: Constant <code>1</code></li> <li>Message type</li> <li>Message payload</li> <li>Newline</li> </ul> <p>An example message can be seen as <code>%1:1:0</code>, message type one is program suspend. It should be noted that if more than three message seperator characters are used then any located after the third are ignored and are merged into the message payload.</p> <p>If we have the message <code>%1:2:0:1:2:3</code> then the message payload should be <code>0:1:2:3</code>, the extra message separator characters do not mess up the parser state and does not throw a warning or error of any kind</p>"},{"location":"protocol/v1/#message-types","title":"Message Types","text":"<p>Message types are defined as enums within <code>v5dbg/protocol.h</code> (include directory), the <code>DEBUGGER_MESSAGE_MAX</code> is used as a basic check to determine if a message type is invalid. </p> <p>Message IDs can be considered <code>unsigned int</code>s since they never can be negative, and a message should be assumed invalid or corrupted if so.</p> <pre><code>enum v5dbg_message_type_e\n{\n  /// @brief  Connection opened\n  DEBUGGER_MESSAGE_OPEN = 0,\n\n  /// @brief  Request program suspension, assume it has occurred when a DEBUG_MESSAGE_RSUSPEND is parsed\n  DEBUGGER_MESSAGE_SUSPEND = 1,\n\n  /// @brief  Connection closed\n  DEBUGGER_MESSAGE_CLOSE = 2,\n\n  /// @brief  Allocate a string, can be processed by the debugger however it likes\n  DEBUGGER_MESSAGE_ALLOCATE_STRING = 3,\n\n  /// @brief  Resume the program from a suspended state\n  DEBUGGER_MESSAGE_RESUME = 4,\n\n  /// @brief  Respond with DEBUGGER_MESSAGE_RTHREADS containing a comma separated list of every thread being managed by\n  /// v5dbg\n  DEBUGGER_MESSAGE_THREADS = 5,\n\n  /// @brief  Return message for DEBUGGER_MESSAGE_THREADS\n  DEBUGGER_MESSAGE_RTHREADS = 6,\n\n  /// @brief  Get the vstack for the given thread index\n  DEBUGGER_MESSAGE_VSTACK_FOR = 7,\n\n  /// @brief  Return message for DEBUGGER_MESSAGE_VSTACK_FOR, keep accepting messages until DEBUGGER_MESSAGE_VSTACK_END\n  DEBUGGER_MESSAGE_RVSTACK = 8,\n\n  /// @brief  Stop accepting DEBUGGER_MESSAGE_RVSTACK messages\n  DEBUGGER_MESSAGE_VSTACK_END = 9,\n\n  /// @brief  List memory for the given stack frame with thread ID\n  DEBUGGER_MESSAGE_LMEM_FOR = 10,\n\n  /// @brief  Returned message for DEBUGGER_MESSAGE_LMEM_FOR, keep accepting messages until DEBUGGER_MESSAGE_LMEM_END\n  DEBUGGER_MESSAGE_RLMEM = 11,\n\n  /// @brief  Stop accepting DEBUGGER_MESSAGE_RLMEM messages\n  DEBUGGER_MESSAGE_LMEM_END = 12,\n\n  /// @brief  Max debugger message ID\n  DEBUGGER_MESSAGE_MAX = 13\n};\n</code></pre>"},{"location":"protocol/v1/#behaviors","title":"Behaviors","text":""},{"location":"protocol/v1/#debugger_message_suspend","title":"<code>DEBUGGER_MESSAGE_SUSPEND</code>","text":"<p>Requests the debug server to suspend all of its managed threads, no response is sent to the client.</p>"},{"location":"protocol/v1/#debugger_message_vstack_for","title":"<code>DEBUGGER_MESSAGE_VSTACK_FOR</code>","text":"<p>Returns a series of <code>DEBUGGER_MESSAGE_RVSTACK</code> for each frame of the stack before ending with a <code>DEBUGGER_MESSAGE_VSTACK_END</code></p> Parameter Docs Index 0 <code>unsigned int</code> of the thread ID to grab the callstack for"}]}