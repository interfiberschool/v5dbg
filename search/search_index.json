{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"V5 Debugger","text":"<p>The only true VEX debugger\u2122</p>"},{"location":"#what-is-v5dbg","title":"What is v5dbg?","text":"<p>V5dbg is an experimental debugger for the V5 brain used in V5 Robotics competitions.</p>"},{"location":"#what-can-v5dbg-do","title":"What can v5dbg do?","text":"<ul> <li>Set software breakpoints<ul> <li>Set breakpoints on function entrance/exit, memory allocations, and manual locations</li> <li>Conditional breakpoints</li> </ul> </li> <li>Inspect active threads<ul> <li>View active locks and which threads hold them</li> <li>View the generated callstack for a thread at any time</li> <li>Easily switch the debuggers active context to another thread</li> </ul> </li> <li>Inspect, set, and manage memory<ul> <li>Automatically pretty print variables based on compile-time type information</li> <li>Set memory value to a constant, variable constant, or temporary value.<ul> <li>Constant set = Every time this variable is allocated set it to <code>x</code></li> <li>Variable constant = Every time this variable is allocated with <code>y</code> change it to <code>x</code></li> <li>Temporary value = Set this variable to <code>x</code> when reallocation occurs it willl change back to <code>y</code></li> </ul> </li> </ul> </li> <li>Inspect device states<ul> <li>Motor information</li> <li>Battery power</li> <li>Connected remote information</li> <li>Radio I/O</li> </ul> </li> </ul>"},{"location":"#limitations-of-v5dbg","title":"Limitations of v5dbg","text":"<ul> <li>Every function must begin with <code>$function</code></li> <li>Variables accessible by the debugger must be fed into <code>$expose</code></li> <li>If your program has a fatal crash v5dbg cannot suspend the program.</li> <li>Line-by-line stepping is not possible</li> </ul>"},{"location":"install/","title":"Installation","text":"<p>Installation of the v5dbg server</p>"},{"location":"integration/","title":"Integration","text":""},{"location":"integration/#step-1-allocate-the-server-state-object","title":"Step 1. Allocate the server state object","text":"<p>v5dbg relies on a core server state object to contain the debuggers state. Find a place in your program like <code>main.cpp</code> where you can place the global server state object like below:</p> <pre><code>// .. snip ..\n#include \"v5dbg/server.h\"\n\nv5dbg_server_state_t serverState{};\n</code></pre> <p>Now we can initialize it with <code>V5Dbg_AllocateServerState</code> inside our <code>initialize</code> function like so</p> <pre><code>void\ninitialize()\n{\n    // Allocate server state heap resources\n    serverState = V5Dbg_AllocateServerState();\n}\n</code></pre>"},{"location":"integration/#step-2-start-the-debug-server","title":"Step 2. Start the debug server","text":"<p>In order to start integrating v5dbg into our bot code we need to actually start the debug server. Still in our <code>initialize</code> function we can add a call to <code>V5Dbg_StartServer</code> which takes in a pointer to the <code>v5dbg_server_state_t</code> object we allocated in the previous step. Our file should now look similar to whats below</p> <pre><code>#include \"v5dbg/server.h\"\n\nv5dbg_server_state_t serverState{};\n\nvoid\ninitialize()\n{\n    // Allocate server state heap resources\n    serverState = V5Dbg_AllocateServerState();\n\n    // Start the debug server\n    V5Dbg_StartServer(&amp;serverState);\n}\n</code></pre>"},{"location":"integration/#step-3-inform-the-debugger-of-new-tasks","title":"Step 3. Inform the debugger of new tasks","text":"<p>Right now the debug server is waiting for messages and API calls. We need to tell the debug server of any new tasks that we create, including ones automatically created by the PROS system daemon, such as <code>opcontrol</code>. Lets just to the first line of code in our <code>opcontrol</code> function.</p> <p>Here lets tell the debugger about the new task using <code>V5Dbg_Init</code></p> <pre><code>void\nopcontrol()\n{\n    // Will automatically tell the debugger to supervise execution of the current task\n    V5Dbg_Init();\n\n    // If we want to be more verbose we can use the following which is what V5Dbg_Init does behind the scenes.\n    V5Dbg_RemoteInit(pros::rtos::Task::current_task());\n\n    while (true)\n    {\n        // ... opcontrol code ...\n    }\n\n    // Our task is about to be deleted so inform the debugger to stop supervising it\n    V5Dbg_Leave();\n}\n</code></pre> <p>V5dbg also offers a macro named <code>$ntask</code> which will automatically supervise and shutdown resources as needed.</p> <pre><code>#include \"v5dbg/debug.h\" // Needed for all debug macros like $ntask\n\nvoid opcontrol()\n{\n    $ntask\n\n    while (true)\n    {\n        // ... opcontrol code ...\n    }\n}\n</code></pre>"},{"location":"integration/#step-4-start-tracking-function-calls","title":"Step 4. Start tracking function calls","text":"<p>Now we can use normal debugging macros! At the start of every function we can place a call to <code>$function</code> which will allow the debugger to generate stack traces in realtime when pausing our program. You should also make sure to call <code>$function</code> after informing the debugger of the <code>opcontrol</code> task so it shows up in stack traces!</p> <pre><code>void \nprintData(const std::string &amp;msg)\n{\n    $function\n\n    printf(\"%s\\n\", msg.c_str());\n\n    pros::delay(1000); // So we can see `printData` in the callstack!\n}\n</code></pre> <p>For more information on debugger macros see the Macros and Functions &amp; Classes section, or view the Debugger Client documentation.</p>"},{"location":"macros/","title":"Macros","text":"<p>All macros should be defined in the <code>v5dbg/debug.h</code> header file, make sure to include this!</p>"},{"location":"macros/#function","title":"<code>$function</code>","text":"<p>Makes the currently scoped function debuggable.</p> <p>NOTE: Without this function 99% of program debugging functions will not work, and this frame will be hidden from stack traces.</p>"},{"location":"macros/#example","title":"Example","text":"<pre><code>// Some dummy functions to demonstrate $function\n\n/**\n * Set the drivetrain voltage\n * @param power Power in volts\n*/\nvoid\ndriveVoltage(int power)\n{\n    $function\n\n    driveTrain-&gt;setVoltage(power);\n}\n\nvoid\ndriveTime(int ms)\n{\n    $function // Make sure we appear in stack traces and stuff!\n\n    // Drive forward at 20 volts for `ms` time\n    driveVoltage(20);\n\n    pros::delay(ms);\n\n    driveVoltage(0); // Reset power after sleep\n}\n</code></pre>"},{"location":"macros/#ntask","title":"<code>$ntask</code>","text":"<p>Informs the debugger of a new task to supervise, this should be the first line of code within every function.</p> <p>NOTE: When <code>$ntask</code> falls out of scope the task is automatically dropped from the debugger making it undebuggable.</p>"},{"location":"macros/#example_1","title":"Example","text":"<pre><code>void\nopcontrol()\n{\n    $ntask // Operator control task was spawned by the PROS system daemon, make sure the debugger knows this\n\n    while (true)\n    {\n        // .. opcontrol stuff .. \n\n        pros::delay(20); // Allow RTOS to perform a context switch\n    }\n}\n</code></pre>"},{"location":"macros/#exposet","title":"<code>$expose(t)</code>","text":"<p>Expose a scoped variable to the debug server for inspection.</p>"},{"location":"macros/#example_2","title":"Example","text":"<pre><code>void\nopcontrol()\n{\n    int fwdVoltage = 200;\n    $expose(fwdVoltage); // Expose the fwdVoltage variable to the debugger, the $expose macro will automatically get type information for us &amp; the pretty printer\n\n    while (true)\n    {\n        if (ButtonPressed(BUTTON_X))\n        {\n            driveVoltage(fwdVoltage);\n        }\n        else\n        {\n            driveVoltage(0);\n        }\n    }\n}\n</code></pre>"},{"location":"macros/#break","title":"<code>$break</code>","text":"<p>Place non-conditional breakpoint at this location in the program. This breakpoint can be enabled by referencing its file and line number.</p>"},{"location":"macros/#example_3","title":"Example","text":"<pre><code>void opcontrol()\n{\n\n    // Segfault here\n    DriveTrain* drive = nullptr;\n    $expose(drive); // Expose drivetrain memory address to debugger\n\n    // What went wrong? Place a breakpoint to inspect state!\n    $break\n\n    drive-&gt;calibrate();\n\n}\n</code></pre>"},{"location":"macros/#cbreakcond","title":"<code>$cbreak(cond)</code>","text":"<p>Place conditional breakpoint at this location in the program. This breakpoint can be enabled by referencing its file and line number.</p> <p>NOTE: You still have to enable this breakpoint but it will only fire when the condition provided is true.</p>"},{"location":"macros/#example_4","title":"Example","text":"<pre><code>void opcontrol()\n{\n\n    // Segfault here\n    DriveTrain* drive = makeDrivetrain();\n    $expose(drive); // Expose drivetrain memory address to debugger\n\n    // If drivetrain failed to build then break for debugging!\n    $cbreak(drive == nullptr)\n\n    drive-&gt;calibrate();\n\n}\n</code></pre>"},{"location":"protocol/v1/","title":"V5 Debugger Server Protocol v1","text":""},{"location":"protocol/v1/#constants","title":"Constants","text":"<p>The following constants will be used throughout the protocol documentation.</p> Constant Value Newline <code>\\n</code> Message A string of characters with a newline at the end Message separator <code>:</code> Debugger The program that connects to the debug server over serial Debug server Program that runs on the brain and provides debugging functions over serial Remote Device running the debug server Local Device running the debugger Protocol version The number used to determine the version of the protocol"},{"location":"protocol/v1/#communication","title":"Communication","text":"<p>v5dbg communicates over USB serial using the standard <code>printf</code> function. Incoming commands are read from <code>std::cin</code> on the debug server's IO thread and are pushed into a message queue which is read by the main thread. Data is automatically sent to the computer using the V5 serial protocol which will not be discussed in this document.</p>"},{"location":"protocol/v1/#messages","title":"Messages","text":"<p>Messages are payloads of data sent from either the debugger, or debug server. All messages are formatted as follows, left to right.</p> <ul> <li>Message begin <code>%</code></li> <li>Protocol version: Constant <code>1</code></li> <li>Message type</li> <li>Message payload</li> <li>Newline</li> </ul> <p>An example message can be seen as <code>%1:1:0</code>, message type one is program suspend. It should be noted that if more than three message seperator characters are used then any located after the third are ignored and are merged into the message payload.</p> <p>If we have the message <code>%1:2:0:1:2:3</code> then the message payload should be <code>0:1:2:3</code>, the extra message separator characters do not mess up the parser state and does not throw a warning or error of any kind</p>"},{"location":"protocol/v1/#message-types","title":"Message Types","text":"<p>Message types are defined as enums within <code>v5dbg/protocol.h</code> (include directory), the <code>DEBUGGER_MESSAGE_MAX</code> is used as a basic check to determine if a message type is invalid. </p> <p>Message IDs can be considered <code>unsigned int</code>s since they never can be negative, and a message should be assumed invalid or corrupted if so.</p> <pre><code>enum v5dbg_message_type_e\n{\n  /// @brief  Connection opened\n  DEBUGGER_MESSAGE_OPEN = 0,\n\n  /// @brief  Request program suspension, assume it has occurred when a DEBUG_MESSAGE_RSUSPEND is parsed\n  DEBUGGER_MESSAGE_SUSPEND = 1,\n\n  /// @brief  Connection closed\n  DEBUGGER_MESSAGE_CLOSE = 2,\n\n  /// @brief  Allocate a string, can be processed by the debugger however it likes\n  DEBUGGER_MESSAGE_ALLOCATE_STRING = 3,\n\n  /// @brief  Resume the program from a suspended state\n  DEBUGGER_MESSAGE_RESUME = 4,\n\n  /// @brief  Respond with DEBUGGER_MESSAGE_RTHREADS containing a comma separated list of every thread being managed by\n  /// v5dbg\n  DEBUGGER_MESSAGE_THREADS = 5,\n\n  /// @brief  Return message for DEBUGGER_MESSAGE_THREADS\n  DEBUGGER_MESSAGE_RTHREADS = 6,\n\n  /// @brief  Get the vstack for the given thread index\n  DEBUGGER_MESSAGE_VSTACK_FOR = 7,\n\n  /// @brief  Return message for DEBUGGER_MESSAGE_VSTACK_FOR, keep accepting messages until DEBUGGER_MESSAGE_VSTACK_END\n  DEBUGGER_MESSAGE_RVSTACK = 8,\n\n  /// @brief  Stop accepting DEBUGGER_MESSAGE_RVSTACK messages\n  DEBUGGER_MESSAGE_VSTACK_END = 9,\n\n  /// @brief  List memory for the given stack frame with thread ID\n  DEBUGGER_MESSAGE_LMEM_FOR = 10,\n\n  /// @brief  Returned message for DEBUGGER_MESSAGE_LMEM_FOR, keep accepting messages until DEBUGGER_MESSAGE_LMEM_END\n  DEBUGGER_MESSAGE_RLMEM = 11,\n\n  /// @brief  Stop accepting DEBUGGER_MESSAGE_RLMEM messages\n  DEBUGGER_MESSAGE_LMEM_END = 12,\n\n  /// @brief  Max debugger message ID\n  DEBUGGER_MESSAGE_MAX = 13\n};\n</code></pre>"},{"location":"protocol/v1/#behaviors","title":"Behaviors","text":""},{"location":"protocol/v1/#debugger_message_suspend","title":"<code>DEBUGGER_MESSAGE_SUSPEND</code>","text":"<p>Requests the debug server to suspend all of its managed threads, no response is sent to the client.</p>"},{"location":"protocol/v1/#debugger_message_vstack_for","title":"<code>DEBUGGER_MESSAGE_VSTACK_FOR</code>","text":"<p>Returns a series of <code>DEBUGGER_MESSAGE_RVSTACK</code> for each frame of the stack before ending with a <code>DEBUGGER_MESSAGE_VSTACK_END</code></p> Parameter Docs Index 0 <code>unsigned int</code> of the thread ID to grab the callstack for"}]}