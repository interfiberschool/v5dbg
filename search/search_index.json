{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"V5 Debugger","text":"<p>The only true VEX debugger\u2122</p> <p>V5dbg is still experimental</p> <p>v5dbg is still under HEAVY development and the documentation may not reflect the current state of the library and program.</p> <p> Bug Tracker</p> <p> Releases Page</p>"},{"location":"#what-can-v5dbg-do","title":"What can v5dbg do?","text":"<ul> <li> <p> Set software breakpoints</p> <ul> <li>Set breakpoints on function entrance/exit, memory allocations, and in manual locations.</li> <li>Conditional breakpoints <code>$cbreak</code></li> </ul> <p> C++ Documentation</p> <p> Debugger Documentation</p> </li> <li> <p> Inspect active threads</p> <ul> <li>View active locks and which threads hold them</li> <li>View the current callstack for a thread at any time</li> <li>Easily switch the debuggers active context to another thread</li> </ul> <p> C++ Documentation</p> <p> Debugger Documentation</p> </li> <li> <p> Inspect, set, and manage memory</p> <ul> <li>Automatically pretty print variables based on compile-time type information</li> <li>Set memory value to a constant, variable constant, or temporary value</li> </ul> <p> C++ Documentation</p> <p> Debugger Documentation</p> </li> <li> <p> Inspect device states</p> <ul> <li>Motor information</li> <li>Battery power</li> <li>Connected remote information</li> <li>Radio I/O</li> </ul> <p> C++ Documentation</p> <p> Debugger Documentation</p> </li> </ul> <p>Ready to get started?</p>"},{"location":"cpp/header_files/","title":"Header files","text":"File Description <code>v5dbg/debug.h</code> All debug macros for user programs <code>v5dbg/memory.h</code> Memory object handling <code>v5dbg/protocol.h</code> Debug protocol spec <code>v5dbg/debinfo.h</code> Runtime debug info <code>v5dbg/pretty.h</code> Pretty printer functions <code>v5dbg/debugger.h</code> Debugger functions (suspend, resume) <code>v5dbg/msg.h</code> Message handling definitions <code>v5dbg/stack.h</code> Stack reconstruction <code>v5dbg/server.h</code> Debug server implementation <code>v5dbg/util.h</code> Utility functions"},{"location":"cpp/macros/debug/function/","title":"<code>$function</code>","text":"<p>Version information</p> <p>Introduced in version v0.1 </p> <p>This macro is considered stable </p>"},{"location":"cpp/macros/debug/function/#about","title":"About","text":"<p>The <code>$function</code> macro allows v5dbg to generate a backtrace to determine the current point of execution. When placed at the top of a function it adds debug information to the current backtrace, when the function exits its then removed.</p> Why do I need to use this macro? <p>Unlike traditional debuggers which can ask the operating system for a backtrace and can then convert the returned addresses into symbol names, v5dbg runs on an environment where this is not possible (yet).</p> <p>As a workaround <code>$function</code> traces where it was called from to determine the proper line of execution.</p>"},{"location":"cpp/macros/debug/function/#notes","title":"Notes","text":"<p>Required environment</p> <ul> <li>This macro requires the debug server to have been initialized before being called.</li> <li>This macro requires the current thread to be supervised with $ntask or <code>V5Dbg_Init</code></li> </ul>"},{"location":"cpp/macros/debug/function/#examples","title":"Examples","text":"Example 1 (Single function)Example 2 <pre><code>#include \"v5dbg/debug.h\"\n\nvoid\nopcontrol()\n{\n    $ntask // (1)!\n    $function // (2)!\n\n    while (true)\n    {\n        // Print \"Hello World\" to the screen via pros::lcd\n        pros::lcd::print(1, \"Hello World\");\n\n        pros::delay(300);\n    }\n}\n</code></pre> <ol> <li>For more information on <code>$ntask</code> look here</li> <li>Now opcontrol will be the first item in the callstack since it's the first time <code>$function</code> was called on this thread/task.</li> </ol> <pre><code>#include \"v5dbg/debug.h\"\n\nvoid\nprintAndSleep(const std::string &amp;p)\n{\n    $function // (2)!\n    pros::lcd::print(1, \"%s\", p.c_str()); // Print our data to the screen\n\n    pros::delay(300); // Wait 300ms\n}\n\nvoid\nopcontrol()\n{\n    $ntask // (1)!\n    $function\n\n    while (true)\n    {\n        printAndSleep(\"Hello World\");\n    }\n}\n</code></pre> <ol> <li>For more information on <code>$ntask</code> look here</li> <li>Now our <code>printAndSleep</code> function will be the second item in the callstack, it should now look like this:<ul> <li><code>void printAndSleep(const std::string &amp;p)</code></li> <li><code>void opcontrol()</code></li> </ul> </li> </ol>"},{"location":"cpp/macros/debug/ntask/","title":"<code>$ntask</code>","text":"<p>Version information</p> <p>Introduced in version v0.1 </p> <p>This macro is considered stable </p>"},{"location":"cpp/macros/debug/ntask/#about","title":"About","text":"<p>The <code>$ntask</code> macro informs the debug server of a newly spawned thread/task. It should be the first line of code ever executed during a tasks runtime, otherwise other debug macros may not work.</p> <p>Common pitfall</p> <p>When <code>$ntask</code> falls out of scope it will automatically prevent the debugger from supervising the task, make sure that the scope its called in lives until the task is ready to end.</p>"},{"location":"cpp/macros/debug/ntask/#notes","title":"Notes","text":"<p>Required environment</p> <ul> <li>This macro requires the debug server to have been initialized before being called.</li> </ul> <p>Task names</p> <p>Make sure that every task has a unique name otherwise tasks can be confused internally by the debug server.</p>"},{"location":"cpp/macros/debug/ntask/#example","title":"Example","text":"<pre><code>#include \"v5dbg/debug.h\"\n\nvoid\nopcontrol()\n{\n    $ntask // (1)!\n    $function // (2)!\n\n    while (true)\n    {\n        // Print \"Hello World\" to the screen via pros::lcd\n        pros::lcd::print(1, \"Hello World\");\n\n        pros::delay(300);\n    }\n}\n</code></pre> <ol> <li>Our thread is now supervised and we can begin to use other debug macros.</li> <li>For more information on <code>$function</code> look here</li> </ol>"},{"location":"debug_server/exposed_memory/","title":"Exposed memory","text":""},{"location":"debug_server/exposed_memory/#limitations","title":"Limitations","text":"<p>Exposing memory would be easy if PROS provided a better way to capture debug information and read it at runtime. On Linux systems debug info for executables is usually stored in the DWARF format and is used by debuggers to find the addresses of variables along with information on data types and functions.</p>"},{"location":"debug_server/exposed_memory/#our-solution","title":"Our Solution","text":""},{"location":"debug_server/exposed_memory/#memory-types-and-the-type-database","title":"Memory Types and the Type Database","text":"<p>v5dbg has a list of predefined, but extendable, memory types. Since memory types are just enums they do not directly convert into C++ types.</p> <p>In order to convert a C++ type into a <code>v5dbg_memory_type_e</code> we use the type database which stores the <code>hash_code</code> of a <code>std::type_info</code> as the key and the memory type as the value.</p>"},{"location":"debug_server/exposed_memory/#expose-macro","title":"<code>$expose</code> macro","text":"<p>The <code>$expose</code> macro takes in a variable and allows it to be exposed to the debugger. When <code>$expose</code> is invoked it generates code to register a <code>void*</code> to the variable with the debug server along with any type information which is obtained with the <code>typeid</code> operator.</p> <p>When the <code>$expose</code> macro falls out of scope it automatically marks the variable as deallocated with the debug server. More information on how actual reading of variable memory can be found in the pretty printers section.</p>"},{"location":"debug_server/stack/","title":"Stack traces","text":""},{"location":"debug_server/stack/#limitations","title":"Limitations","text":"<p>Unlike debuggers for desktop operating system which can request backtraces using system calls such as backtrace(3), neither PROS or VexOS offer a way to obtain such information from the user program.</p>"},{"location":"debug_server/stack/#our-solution","title":"Our Solution","text":"<p>C++ offers a feature to classes called destructors which do the opposite of their constructor and usually ends up freeing resources. </p> <p>v5dbg uses these to its advantage with the <code>V5DbgFunction</code> class. When this class is constructed its fed in location information obtained from the <code>__PRETTY__FUNCTION__</code>, <code>__FILE__</code>, and <code>__LINE__</code> macros. In the constructor we access the current virtual callstack vector for our thread and push all this debug info into it at the last index.</p> <p>The C++ compiler will automatically call the destructor once this class instance falls out of scope in the current function, inside our destructor we call <code>pop_back</code> on the current virtual callstack vector.</p> <p>With this method, a function's debug information is inserted onto the virtual callstack at the proper location and is available for the entire duration of its execution. When we wish to inspect the callstack, like for <code>DEBUGGER_MESSAGE_VSTACK_FOR</code> messages, we simply loop through the proper callstack vector.</p> <p>Since collecting debug info and constructing classes is annoying to do manually for every function its been compressed into a singular macro called <code>$function</code>, when this macro is used at the top of a function it generates the code required to generate stack traces and places the <code>V5DbgFunction</code> class instance in a local variable named <code>_v5dbg_stack_func</code></p>"},{"location":"debug_server/stack/#future-alternatives","title":"Future Alternatives","text":"<p>In the future libunwind could be used to obtain a backtrace without the use of <code>$function</code>. Since <code>libunwind</code> only returns addresses it would be up to the debugger to convert them into human readable locations with tools such as <code>addr2line</code>.</p>"},{"location":"debugger/cmds/backtrace/","title":"<code>backtrace</code>","text":"<p>Command information</p> <p>Regular name <code>backtrace</code> </p> <p>Other names <code>bt</code>, <code>stack</code> </p> <p>Introduced in version v0.1 </p>"},{"location":"debugger/cmds/backtrace/#about","title":"About","text":"<p>The <code>backtrace</code> command is used to obtain the current callstack of the suspended program's selected thread.</p>"},{"location":"debugger/cmds/backtrace/#notes","title":"Notes","text":"<p>Warning</p> <p>This command will only print a stacktrace when the program is in the <code>SUSPEND</code> state.</p>"},{"location":"debugger/cmds/backtrace/#syntax","title":"Syntax","text":"<p>This command accepts no arguments.</p>"},{"location":"debugger/cmds/frame/","title":"<code>frame</code>","text":"<p>Command information</p> <p>Regular name <code>frame</code> </p> <p>Introduced in version v0.1 </p>"},{"location":"debugger/cmds/frame/#about","title":"About","text":"<p>The <code>frame</code> command is used to change the frame the debugger is inspecting on the callstack</p>"},{"location":"debugger/cmds/frame/#syntax","title":"Syntax","text":"<p>When invoked with no arguments this command prints out the current frame ID.</p> <p>When invoked with a single integer argument this command changes the frame ID to the argument and prints out the new active frame state.</p>"},{"location":"debugger/cmds/mem/","title":"<code>mem</code>","text":"<p>Command information</p> <p>Regular name <code>mem</code> </p> <p>Introduced in version v0.1 </p>"},{"location":"debugger/cmds/mem/#about","title":"About","text":"<p>The <code>mem</code> command is used to print out all local variables in the current stack frame, their types, and allocation points. To get the value of a variable see print</p>"},{"location":"debugger/cmds/mem/#notes","title":"Notes","text":"<p>Warning</p> <p>This command only displays the variables in the current scope.</p>"},{"location":"debugger/cmds/mem/#syntax","title":"Syntax","text":"<p>This command accepts no arguments.</p>"},{"location":"debugger/cmds/print/","title":"<code>print</code>","text":"<p>Command information</p> <p>Regular name <code>print</code> </p> <p>Other names <code>p</code> </p> <p>Introduced in version v0.1 </p>"},{"location":"debugger/cmds/print/#about","title":"About","text":"<p>The <code>print</code> command is used to obtain the value of a variable within the current stack frame's scope.</p>"},{"location":"debugger/cmds/print/#syntax","title":"Syntax","text":"<p>This command requires a string argument to be passed to it as the variable name. The variables type, name, and value are then displayed to the console.</p>"},{"location":"debugger/cmds/resume/","title":"<code>resume</code>","text":"<p>Command information</p> <p>Regular name <code>resume</code> </p> <p>Other names <code>c</code>, <code>continue</code> </p> <p>Introduced in version v0.1 </p>"},{"location":"debugger/cmds/resume/#about","title":"About","text":"<p>The <code>resume</code> command is used to resume all supervised tasks running on the brain, execution can be suspended at a later time.</p>"},{"location":"debugger/cmds/resume/#notes","title":"Notes","text":"<p>Warning</p> <p>This command will only resume execution when the program is detected to be in the <code>SUSPEND</code> state.</p>"},{"location":"debugger/cmds/resume/#syntax","title":"Syntax","text":"<p>This command accepts no arguments.</p>"},{"location":"debugger/cmds/state/","title":"<code>state</code>","text":"<p>Command information</p> <p>Regular name <code>state</code> </p> <p>Introduced in version v0.1 </p>"},{"location":"debugger/cmds/state/#about","title":"About","text":"<p>The <code>print</code> command is used to view the state of the program *according to the debugger.</p>"},{"location":"debugger/cmds/state/#notes","title":"Notes","text":"<p>Bug</p> <p>When the program is suspended, then the debugger is quit, and then reopened again the program state can show up wrong.</p>"},{"location":"debugger/cmds/state/#syntax","title":"Syntax","text":"<p>This command accepts no arguments.</p>"},{"location":"debugger/cmds/suspend/","title":"<code>suspend</code>","text":"<p>Command information</p> <p>Regular name <code>suspend</code> </p> <p>Other names <code>s</code>, <code>halt</code> </p> <p>Introduced in version v0.1 </p>"},{"location":"debugger/cmds/suspend/#about","title":"About","text":"<p>The <code>suspend</code> command is used to suspend all supervised tasks running on the brain, execution can be resumed at a later time.</p>"},{"location":"debugger/cmds/suspend/#notes","title":"Notes","text":"<p>Warning</p> <p>This command will only suspend execution when the program is detected to be in the <code>RUN</code> state.</p>"},{"location":"debugger/cmds/suspend/#syntax","title":"Syntax","text":"<p>This command accepts no arguments.</p>"},{"location":"debugger/cmds/thread/","title":"<code>thread</code>","text":"<p>Command information</p> <p>Regular name <code>thread</code> </p> <p>Introduced in version v0.1 </p>"},{"location":"debugger/cmds/thread/#about","title":"About","text":"<p>The <code>thread</code> command is used to view and modify threads.</p>"},{"location":"debugger/cmds/thread/#syntax","title":"Syntax","text":"<p>When invoked with no arguments then all threads are listed, when invoked with an integer argument the active thread is changed to the given ID.</p>"},{"location":"getting_started/integration/","title":"Integration","text":""},{"location":"getting_started/integration/#step-1-allocate-the-server-state-object","title":"Step 1. Allocate the server state object","text":"<p>v5dbg relies on a core server state object to contain the debuggers state. Find a place in your program like <code>main.cpp</code> where you can place the global server state object like below:</p> <pre><code>// .. snip ..\n#include \"v5dbg/server.h\"\n\nv5dbg_server_state_t serverState{};\n</code></pre> <p>Now we can initialize it with <code>V5Dbg_AllocateServerState</code> inside our <code>initialize</code> function like so</p> <pre><code>void\ninitialize()\n{\n    // Allocate server state heap resources\n    serverState = V5Dbg_AllocateServerState();\n}\n</code></pre>"},{"location":"getting_started/integration/#step-2-start-the-debug-server","title":"Step 2. Start the debug server","text":"<p>In order to start integrating v5dbg into our bot code we need to actually start the debug server. Still in our <code>initialize</code> function we can add a call to <code>V5Dbg_StartServer</code> which takes in a pointer to the <code>v5dbg_server_state_t</code> object we allocated in the previous step. Our file should now look similar to whats below</p> <pre><code>#include \"v5dbg/server.h\"\n\nv5dbg_server_state_t serverState{};\n\nvoid\ninitialize()\n{\n    // Allocate server state heap resources\n    serverState = V5Dbg_AllocateServerState();\n\n    // Start the debug server\n    V5Dbg_StartServer(&amp;serverState);\n}\n</code></pre>"},{"location":"getting_started/integration/#step-3-inform-the-debugger-of-new-tasks","title":"Step 3. Inform the debugger of new tasks","text":"<p>Right now the debug server is waiting for messages and API calls. We need to tell the debug server of any new tasks that we create, including ones automatically created by the PROS system daemon, such as <code>opcontrol</code>. Lets just to the first line of code in our <code>opcontrol</code> function.</p> <p>Here lets tell the debugger about the new task using <code>V5Dbg_Init</code></p> <pre><code>void\nopcontrol()\n{\n    // Will automatically tell the debugger to supervise execution of the current task\n    V5Dbg_Init();\n\n    // If we want to be more verbose we can use the following which is what V5Dbg_Init does behind the scenes.\n    V5Dbg_RemoteInit(pros::rtos::Task::current_task());\n\n    while (true)\n    {\n        // ... opcontrol code ...\n    }\n\n    // Our task is about to be deleted so inform the debugger to stop supervising it\n    V5Dbg_Leave();\n}\n</code></pre> <p>V5dbg also offers a macro named <code>$ntask</code> which will automatically supervise and shutdown resources as needed.</p> <pre><code>#include \"v5dbg/debug.h\" // Needed for all debug macros like $ntask\n\nvoid opcontrol()\n{\n    $ntask\n\n    while (true)\n    {\n        // ... opcontrol code ...\n    }\n}\n</code></pre>"},{"location":"getting_started/integration/#step-4-start-tracking-function-calls","title":"Step 4. Start tracking function calls","text":"<p>Now we can use normal debugging macros! At the start of every function we can place a call to <code>$function</code> which will allow the debugger to generate stack traces in realtime when pausing our program. You should also make sure to call <code>$function</code> after informing the debugger of the <code>opcontrol</code> task so it shows up in stack traces!</p> <pre><code>void \nprintData(const std::string &amp;msg)\n{\n    $function\n\n    printf(\"%s\\n\", msg.c_str());\n\n    pros::delay(1000); // So we can see `printData` in the callstack!\n}\n</code></pre> <p>For more information on debugger macros see the Macros section, or view the Debugger Client documentation.</p>"},{"location":"install/debugger/","title":"Install the v5dbg debugger","text":""},{"location":"install/debugger/#downloading-the-latest-archive","title":"Downloading the latest archive","text":"<p>Download the latest <code>v5dbg_debugger.zip</code> file for your platform from the releases page</p> <ul> <li>For Windows users download <code>v5dbg_debugger_win32.zip</code></li> <li>For GNU/Linux users download <code>v5dbg_debugger_linux64.zip</code></li> <li>MacOS is not currently built by the CI/CD system and archives are not published</li> </ul> Verify checksums <p>If you want to verify that your file has not been tampered with you may check its checksum again the computed ones available on the versions specific release page.</p>"},{"location":"install/debugger/#extract-and-install","title":"Extract and install","text":"<p>Extract the downloaded zip file into an easily accessible location. If you wish to make the <code>v5dbg</code> command available in your shell without using the full path you can add the extracted location to your <code>PATH</code> variable.</p>"},{"location":"install/debugger/#commons-errors","title":"Commons errors","text":"Waiting for user program execution on target to begin.... <p>If you get stuck at this message it means we are still waiting for the user program to start on the brain.</p> <p>Make sure that:</p> <ul> <li>You're wired to the brain over MicroUSB</li> <li>You have started the user program on the brain</li> </ul> Warning! DebugServer (local) has not gotten any OPEN messages from the debug server in over 5s, did the debug server freeze? <p>This means that the debug server running on the brain hasn't sent us any messages in over 5 seconds.</p> <p>This usually means:</p> <ul> <li>The user program &amp; debug server have crashed</li> <li>The serial connection to the debug server has been dropped, try restarting the debugger</li> <li>The user program is hogging CPU resources and not allowing the debug server to execute</li> </ul>"},{"location":"install/server/","title":"Installation","text":"Limitations of v5dbg <p>Please keep the following limitations in mind while using v5dbg.</p> <ul> <li>Every function must begin with <code>$function</code></li> <li>Variables accessible by the debugger must be fed into <code>$expose</code></li> <li>If your program has a fatal crash v5dbg cannot suspend the program.<ul> <li>Try using Symbolizer for VEX V5 in combination with v5dbg.</li> </ul> </li> <li>Line-by-line stepping is not possible</li> </ul>"},{"location":"install/server/#requirements","title":"Requirements","text":"<p>Please read through the requirements carefully</p> <ul> <li>Your user program is developed using PROS</li> <li>PROS toolchain is installed and up-to-date<ul> <li>The easiest way to do this is to use the VSCode extension</li> </ul> </li> </ul>"},{"location":"install/server/#downloading-the-release-archive","title":"Downloading the release archive","text":"<p>Download the latest <code>v5dbg_server.zip</code> from the releases page on GitHub, now extract this archive into your project folder.</p> <p>Pick the correct file!</p> <p>Make sure to download <code>v5dbg_server.zip</code>, and not <code>v5dbg_debugger.zip</code>. </p> Debugger vs Debug Server <p>The debug server is the program that executes on the brain and performs all of the internal debug logic.</p> <p>The debugger is the program that executes on your computer and serves as a frontend to the debug server over USB serial.</p>"},{"location":"install/server/#copy-server-source-code","title":"Copy server source code","text":"<p>Inside the newly created <code>v5dbg</code> folder copy</p> <ul> <li> <code>v5dbg/include/v5dbg</code> into <code>include</code></li> <li> <code>v5dbg/src/v5dbg</code> into <code>src</code></li> </ul>"},{"location":"install/server/#build-your-program","title":"Build your program","text":"<p>Using either the VSCode extension, or by calling <code>pros make</code> from the terminal make sure that your program builds properly, all v5dbg source code files should automatically be detected and compiled in.</p>"},{"location":"protocol/v1/","title":"V5 Debugger Server Protocol v1","text":""},{"location":"protocol/v1/#authors-copyright","title":"Authors &amp; Copyright","text":"<p>All programming, documentation, and spec authoring was done by Hunter Stasonis</p> <p>This program and its documentation have been placed under the MIT License, and is provided without warranty of any kind</p>"},{"location":"protocol/v1/#constants-and-definitions","title":"Constants and Definitions","text":"<p>Throughout this document many words many be underlined with a dotted line, hovering over these words will show their definition.</p>"},{"location":"protocol/v1/#communication","title":"Communication","text":"<p>v5dbg communicates over USB serial. The debug server opens the pseudofile provided by the PROS kernel located at <code>/ser/sout</code> in write mode, messages are serialized and written to this file using <code>fwrite</code>. COBS and stream multiplexing should be disabled for this file so data can be read raw by the debugger.</p>"},{"location":"protocol/v1/#messages","title":"Messages","text":"<p>Messages are payloads of data sent from either the debugger, or debug server. All messages are formatted as follows, left to right.</p> <ul> <li>Message begin</li> <li>Protocol version</li> <li>Message type</li> <li>Message payload</li> <li>Newline</li> </ul> <p>An example message can be seen as <code>%1:1:0</code>, message type one is program suspend. It should be noted that if more than two message separator characters are used then any located after the third are ignored and are merged into the message payload.</p> <p>If we have the message <code>%1:2:0:1:2:3</code> then the message payload should be <code>0:1:2:3</code>, the extra message separator characters do not mess up the parser state and does not throw a warning or error of any kind</p>"},{"location":"protocol/v1/#message-types","title":"Message Types","text":"<p>Message types are defined as enums within <code>v5dbg/protocol.h</code> (include directory), the <code>DEBUGGER_MESSAGE_MAX</code> is used as a basic check to determine if a message type is invalid.</p> <p>Message IDs can be considered <code>unsigned int</code>s since they never can be negative, and a message should be assumed invalid or corrupted if so.</p> <pre><code>enum v5dbg_message_type_e\n{\n  /// @brief  Connection opened\n  DEBUGGER_MESSAGE_OPEN = 0,\n\n  /// @brief  Request program suspension, assume it has occurred when a DEBUG_MESSAGE_RSUSPEND is parsed\n  DEBUGGER_MESSAGE_SUSPEND = 1,\n\n  /// @brief  Connection closed\n  DEBUGGER_MESSAGE_CLOSE = 2,\n\n  /// @brief  Allocate a string, can be processed by the debugger however it likes\n  DEBUGGER_MESSAGE_ALLOCATE_STRING = 3,\n\n  /// @brief  Resume the program from a suspended state\n  DEBUGGER_MESSAGE_RESUME = 4,\n\n  /// @brief  Respond with DEBUGGER_MESSAGE_RTHREADS containing a comma separated list of every thread being managed by\n  /// v5dbg\n  DEBUGGER_MESSAGE_THREADS = 5,\n\n  /// @brief  Return message for DEBUGGER_MESSAGE_THREADS\n  DEBUGGER_MESSAGE_RTHREADS = 6,\n\n  /// @brief  Get the vstack for the given thread index\n  DEBUGGER_MESSAGE_VSTACK_FOR = 7,\n\n  /// @brief  Return message for DEBUGGER_MESSAGE_VSTACK_FOR, keep accepting messages until DEBUGGER_MESSAGE_VSTACK_END\n  DEBUGGER_MESSAGE_RVSTACK = 8,\n\n  /// @brief  Stop accepting DEBUGGER_MESSAGE_RVSTACK messages\n  DEBUGGER_MESSAGE_VSTACK_END = 9,\n\n  /// @brief  List memory for the given stack frame with thread ID\n  DEBUGGER_MESSAGE_LMEM_FOR = 10,\n\n  /// @brief  Returned message for DEBUGGER_MESSAGE_LMEM_FOR, keep accepting messages until DEBUGGER_MESSAGE_LMEM_END\n  DEBUGGER_MESSAGE_RLMEM = 11,\n\n  /// @brief  Stop accepting DEBUGGER_MESSAGE_RLMEM messages\n  DEBUGGER_MESSAGE_LMEM_END = 12,\n\n  /// @brief  Max debugger message ID\n  DEBUGGER_MESSAGE_MAX = 13\n};\n</code></pre>"},{"location":"protocol/v1/#subarguments","title":"Subarguments","text":"<p>Subarguments introduce a way for messages to include more complex data in their 3rd data field. Since the message parser only parses up to the 2nd message separator character the third data field can have message separators located in it.</p> <p>The <code>subargs</code> parser allows for another array of elements to be placed into the data field, the simplest way to perform this would be to split the data field on the message separator character. If we want to include data inside the data field that has message separators(such as C++ typenames) we need an escape character.</p>"},{"location":"protocol/v1/#the-and-character","title":"The <code>[</code> and <code>]</code> character","text":"<p>When the first character of an element is an <code>[</code> we ignore any message separator characters we come across until we encounter a <code>]</code> character located before a message separator or a newline.</p> Without subarguments <p>Imagine we have this message: </p> <p><code>%1:1:std::vector&lt;int&gt;:helloWorld</code></p> <p>It's parameters are broken down into:</p> <ul> <li><code>1</code></li> <li><code>1</code></li> <li><code>std::vector&lt;int&gt;:helloWorld</code></li> </ul> <p>When we split the data parameter of the message by the message separator we get:</p> <ul> <li><code>std</code></li> <li><code>:vector&lt;int&gt;</code></li> <li><code>helloWorld</code></li> </ul> <p>This IS NOT what we want!</p> With subarguments <p>Taking our old string from the previous example and adding subargumrnts we get:</p> <p><code>%1:1:[std::vector&lt;int&gt;]:helloWorld</code></p> <p>It's parameters are broken down the same way during message parsing</p> <p>Now instead of splitting on the message seperator the subargument parser is called creating:</p> <ul> <li><code>std::vector&lt;int&gt;</code></li> <li><code>helloWorld</code></li> </ul> <p>This IS what we want!</p> References <p>You can find the official implementation of a <code>subargs</code> parser on GitHub</p>"},{"location":"protocol/v1/#behaviors","title":"Behaviors","text":"<p>Messages may be marked with icons, hovering over them will show information about the specific message type. Messages that do not state their argument type can be assumed to not use subarguments, or comma splitting. </p> <p>If messages have more than one argument they will specify their argument type next to their enum name in the title.</p>"},{"location":"protocol/v1/#debugger_message_open","title":"<code>DEBUGGER_MESSAGE_OPEN</code>","text":"<p>Sent by the debug server to the debugger at program startup and every 2 seconds that the program is running. The debugger will only connect to the debug server if it can detect and read this message, the debugger will also print a hang message if it fails to receive an <code>OPEN</code> message atleast once every 5 seconds.</p>"},{"location":"protocol/v1/#debugger_message_allocate_string","title":"<code>DEBUGGER_MESSAGE_ALLOCATE_STRING</code>","text":"<p>When sent to the debug server this message sent unaltered back to the debugger, this was used for testing.</p>"},{"location":"protocol/v1/#debugger_message_suspend","title":"<code>DEBUGGER_MESSAGE_SUSPEND</code>","text":"<p>Requests the debug server to suspend all of it's supervised tasks, no response is sent to the client.</p>"},{"location":"protocol/v1/#debugger_message_resume","title":"<code>DEBUGGER_MESSAGE_RESUME</code>","text":"<p>Requests the debug server to resume all of it's supervised tasks, no response is sent to the client.</p>"},{"location":"protocol/v1/#debugger_message_threads","title":"<code>DEBUGGER_MESSAGE_THREADS</code>","text":"<p>Responds with a single <code>DEBUGGER_MESSAGE_RTHREADS</code> message containing all the debugger's supervised threads.</p>"},{"location":"protocol/v1/#debugger_message_rthreads","title":"<code>DEBUGGER_MESSAGE_RTHREADS</code>","text":"<p>Response to a <code>DEBUGGER_MESSAGE_THREADS</code> message.</p> <p>The following parameters repeat for every thread.</p> Parameter Docs Index 0 <code>String</code> Name of the thread Index 1 <code>unsigned int</code> ID of the thread Example message <p><code>%1:6:Worker Thread,0,Odom Thread,1,OpControl,2</code></p>"},{"location":"protocol/v1/#debugger_message_vstack_for","title":"<code>DEBUGGER_MESSAGE_VSTACK_FOR</code>","text":"<p>When sent to the debug server it returns a series of <code>DEBUGGER_MESSAGE_RVSTACK</code> messages for each frame of the stack before ending with a <code>DEBUGGER_MESSAGE_VSTACK_END</code> message.</p> Parameter Docs Index 0 <code>unsigned int</code> Thread ID to grab the callstack for"},{"location":"protocol/v1/#debugger_message_rvstack","title":"<code>DEBUGGER_MESSAGE_RVSTACK</code>","text":"<p>This message is sent repeatedly until a <code>DEBUGGER_MESSAGE_VSTACK_END</code> message is sent.</p> Parameter Docs Index 0 <code>unsigned int</code> of the frame ID Index 1 <code>String</code> Name of the function Index 2 <code>String</code> File path to the function Index 3 <code>unsigned int</code> Line number inside of the file where this function begins"},{"location":"protocol/v1/#debugger_message_vstack_end","title":"<code>DEBUGGER_MESSAGE_VSTACK_END</code>","text":"<p>This message is sent to signal that the debugger can stop waiting for <code>DEBUGGER_MESSAGE_RVSTACK</code> messages.</p> <p>The data field may be filled with any data the server wishes but it can be ignored.</p>"},{"location":"protocol/v1/#debugger_message_lmem_for","title":"<code>DEBUGGER_MESSAGE_LMEM_FOR</code>","text":"<p>This message is sent to the debug server to request a series of <code>DEBUGGER_MESSAGE_RLMEM</code> messages terminated by a <code>DEBUGGER_MESSAGE_LMEM_END</code> which contains captured local memory.</p> Parameter Docs Index 0 <code>unsigned int</code> Frame ID Index 1 <code>unsigned int</code> Thread ID"},{"location":"protocol/v1/#debugger_message_rlmem","title":"<code>DEBUGGER_MESSAGE_RLMEM</code>","text":"<p>This message is sent repeatedly until a <code>DEBUGGER_MESSAGE_LMEM_END</code> message is sent.</p> Parameter Docs Index 0 <code>String</code> C++ typename of this variable Index 1 <code>String</code> Name of this variable Index 2 <code>String</code> Path to the file this variable is in Index 3 <code>unsigned int</code> Line number this variable was exposed on Index 4 <code>String</code> Pretty printed buffer for this variable"},{"location":"protocol/v1/#debugger_message_lmem_end","title":"<code>DEBUGGER_MESSAGE_LMEM_END</code>","text":"<p>This message is sent to signal that the debugger can stop waiting for <code>DEBUGGER_MESSAGE_RLMEM</code> messages.</p> <p>The data field may be filled with any data the server wishes but it can be ignored.</p>"}]}