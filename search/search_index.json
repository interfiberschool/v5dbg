{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"V5 Debugger","text":"<p>The only true debugger\u2122.</p>"},{"location":"#what-is-v5dbg","title":"What is v5dbg?","text":"<p>V5dbg is an experimental debugger for the V5 brain used in V5 Robotics competitions.</p>"},{"location":"#what-can-v5dbg-do","title":"What can v5dbg do?","text":"<ul> <li>Set software breakpoints<ul> <li>Set breakpoints on function entrance/exit, memory allocations, and manual locations</li> <li>Conditional breakpoints</li> </ul> </li> <li>Inspect active threads<ul> <li>View active locks and which threads hold them</li> <li>View the generated callstack for a thread at any time</li> <li>Easily switch the debuggers active context to another thread</li> </ul> </li> <li>Inspect, set, and manage memory<ul> <li>Automatically pretty print variables based on compile-time type information</li> <li>Set memory value to a constant, variable constant, or temporary value.<ul> <li>Constant set = Every time this variable is allocated set it to <code>x</code></li> <li>Variable constant = Every time this variable is allocated with <code>y</code> change it to <code>x</code></li> <li>Temporary value = Set this variable to <code>x</code> when reallocation occurs it willl change back to <code>y</code></li> </ul> </li> </ul> </li> <li>Inspect device states<ul> <li>Motor information</li> <li>Battery power</li> <li>Connected remote information</li> <li>Radio I/O</li> </ul> </li> </ul>"},{"location":"#limitations-of-v5dbg","title":"Limitations of v5dbg","text":"<ul> <li>Every function must begin with <code>$function</code></li> <li>Variables accessible by the debugger must be fed into <code>$expose</code></li> <li>If your program has a fatal crash v5dbg cannot suspend the program.</li> <li>Line-by-line stepping is not possible</li> </ul>"},{"location":"integration/","title":"Integration","text":""},{"location":"integration/#step-1-allocate-the-server-state-object","title":"Step 1. Allocate the server state object","text":"<p>v5dbg relies on a core server state object to contain the debuggers state. Find a place in your program like <code>main.cpp</code> where you can place the global server state object like below:</p> <pre><code>// .. snip ..\n#include \"v5dbg/server.h\"\n\nv5dbg_server_state_t serverState{};\n</code></pre> <p>Now we can initialize it with <code>V5Dbg_AllocateServerState</code> inside our <code>initialize</code> function like so</p> <pre><code>void\ninitialize()\n{\n    // Allocate server state heap resources\n    serverState = V5Dbg_AllocateServerState();\n}\n</code></pre>"},{"location":"integration/#step-2-start-the-debug-server","title":"Step 2. Start the debug server","text":"<p>In order to start integrating v5dbg into our bot code we need to actually start the debug server. Still in our <code>initialize</code> function we can add a call to <code>V5Dbg_StartServer</code> which takes in a pointer to the <code>v5dbg_server_state_t</code> object we allocated in the previous step. Our file should now look similar to whats below</p> <pre><code>#include \"v5dbg/server.h\"\n\nv5dbg_server_state_t serverState{};\n\nvoid\ninitialize()\n{\n    // Allocate server state heap resources\n    serverState = V5Dbg_AllocateServerState();\n\n    // Start the debug server\n    V5Dbg_StartServer(&amp;serverState);\n}\n</code></pre>"},{"location":"integration/#step-3-inform-the-debugger-of-new-tasks","title":"Step 3. Inform the debugger of new tasks","text":"<p>Right now the debug server is waiting for messages and API calls. We need to tell the debug server of any new tasks that we create, including ones automatically created by the PROS system daemon, such as <code>opcontrol</code>. Lets just to the first line of code in our <code>opcontrol</code> function.</p> <p>Here lets tell the debugger about the new task using <code>V5Dbg_Init</code></p> <pre><code>void\nopcontrol()\n{\n    // Will automatically tell the debugger to supervise execution of the current task\n    V5Dbg_Init();\n\n    // If we want to be more verbose we can use the following which is what V5Dbg_Init does behind the scenes.\n    V5Dbg_RemoteInit(pros::rtos::Task::current_task());\n\n    while (true)\n    {\n        // ... opcontrol code ...\n    }\n\n    // Our task is about to be deleted so inform the debugger to stop supervising it\n    V5Dbg_Leave();\n}\n</code></pre> <p>V5dbg also offers a macro named <code>$ntask</code> which will automatically supervise and shutdown resources as needed.</p> <pre><code>#include \"v5dbg/debug.h\" // Needed for all debug macros like $ntask\n\nvoid opcontrol()\n{\n    $ntask\n\n    while (true)\n    {\n        // ... opcontrol code ...\n    }\n}\n</code></pre>"},{"location":"integration/#step-4-start-tracking-function-calls","title":"Step 4. Start tracking function calls","text":"<p>Now we can use normal debugging macros! At the start of every function we can place a call to <code>$function</code> which will allow the debugger to generate stack traces in realtime when pausing our program. You should also make sure to call <code>$function</code> after informing the debugger of the <code>opcontrol</code> task so it shows up in stack traces!</p> <pre><code>void \nprintData(const std::string &amp;msg)\n{\n    $function\n\n    printf(\"%s\\n\", msg.c_str());\n\n    pros::delay(1000); // So we can see `printData` in the callstack!\n}\n</code></pre> <p>For more information on debugger macros see the Macros and Functions &amp; Classes section, or view the Debugger Client documentation.</p>"},{"location":"macros/","title":"Macros","text":"<p>All macros should be defined in the <code>v5dbg/debug.h</code> header file, make sure to include this!</p>"},{"location":"macros/#function","title":"<code>$function</code>","text":"<p>Makes the currently scoped function debuggable.</p> <p>NOTE: Without this function 99% of program debugging functions will not work, and this frame will be hidden from stack traces.</p>"},{"location":"macros/#example","title":"Example","text":"<pre><code>// Some dummy functions to demonstrate $function\n\n/**\n * Set the drivetrain voltage\n * @param power Power in volts\n*/\nvoid\ndriveVoltage(int power)\n{\n    $function\n\n    driveTrain-&gt;setVoltage(power);\n}\n\nvoid\ndriveTime(int ms)\n{\n    $function // Make sure we appear in stack traces and stuff!\n\n    // Drive forward at 20 volts for `ms` time\n    driveVoltage(20);\n\n    pros::delay(ms);\n\n    driveVoltage(0); // Reset power after sleep\n}\n</code></pre>"},{"location":"macros/#ntask","title":"<code>$ntask</code>","text":"<p>Informs the debugger of a new task to supervise, this should be the first line of code within every function.</p> <p>NOTE: When <code>$ntask</code> falls out of scope the task is automatically dropped from the debugger making it undebuggable.</p>"},{"location":"macros/#example_1","title":"Example","text":"<pre><code>void\nopcontrol()\n{\n    $ntask // Operator control task was spawned by the PROS system daemon, make sure the debugger knows this\n\n    while (true)\n    {\n        // .. opcontrol stuff .. \n\n        pros::delay(20); // Allow RTOS to perform a context switch\n    }\n}\n</code></pre>"},{"location":"macros/#exposet","title":"<code>$expose(t)</code>","text":"<p>Expose a scoped variable to the debug server for inspection.</p>"},{"location":"macros/#example_2","title":"Example","text":"<pre><code>void\nopcontrol()\n{\n    int fwdVoltage = 200;\n    $expose(fwdVoltage); // Expose the fwdVoltage variable to the debugger, the $expose macro will automatically get type information for us &amp; the pretty printer\n\n    while (true)\n    {\n        if (ButtonPressed(BUTTON_X))\n        {\n            driveVoltage(fwdVoltage);\n        }\n        else\n        {\n            driveVoltage(0);\n        }\n    }\n}\n</code></pre>"},{"location":"macros/#break","title":"<code>$break</code>","text":"<p>Place non-conditional breakpoint at this location in the program. This breakpoint can be enabled by referencing its file and line number.</p>"},{"location":"macros/#example_3","title":"Example","text":"<pre><code>void opcontrol()\n{\n\n    // Segfault here\n    DriveTrain* drive = nullptr;\n    $expose(drive); // Expose drivetrain memory address to debugger\n\n    // What went wrong? Place a breakpoint to inspect state!\n    $break\n\n    drive-&gt;calibrate();\n\n}\n</code></pre>"},{"location":"macros/#cbreakcond","title":"<code>$cbreak(cond)</code>","text":"<p>Place conditional breakpoint at this location in the program. This breakpoint can be enabled by referencing its file and line number.</p> <p>NOTE: You still have to enable this breakpoint but it will only fire when the condition provided is true.</p>"},{"location":"macros/#example_4","title":"Example","text":"<pre><code>void opcontrol()\n{\n\n    // Segfault here\n    DriveTrain* drive = makeDrivetrain();\n    $expose(drive); // Expose drivetrain memory address to debugger\n\n    // If drivetrain failed to build then break for debugging!\n    $cbreak(drive == nullptr)\n\n    drive-&gt;calibrate();\n\n}\n</code></pre>"}]}